import {
  isLocalId,
  isDeleted,
  winningRev as calculateWinningRev
} from 'pouchdb-merge';
import {
  decodeMetadata,
  encodeMetadata,
} from './utils';
import {
  ATTACH_AND_SEQ_STORE,
  ATTACH_STORE,
  BY_SEQ_STORE,
  DOC_STORE,
  LOCAL_STORE
} from './constants';

// migration to version 2
// unfortunately "deletedOrLocal" is a misnomer now that we no longer
// store local docs in the main doc-store, but whaddyagonnado
function addDeletedOrLocalIndex(txn, callback) {
  var docStore = txn.objectStore(DOC_STORE);
  docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

  docStore.openCursor().onsuccess = function (event) {
    var cursor = event.target.result;
    if (cursor) {
      var metadata = cursor.value;
      var deleted = isDeleted(metadata);
      metadata.deletedOrLocal = deleted ? "1" : "0";
      docStore.put(metadata);
      cursor.continue();
    } else {
      callback();
    }
  };
}

// migration to version 3 (part 2)
function migrateLocalStore(txn, cb) {
  var localStore = txn.objectStore(LOCAL_STORE);
  var docStore = txn.objectStore(DOC_STORE);
  var seqStore = txn.objectStore(BY_SEQ_STORE);

  var cursor = docStore.openCursor();
  cursor.onsuccess = function (event) {
    var cursor = event.target.result;
    if (cursor) {
      var metadata = cursor.value;
      var docId = metadata.id;
      var local = isLocalId(docId);
      var rev = calculateWinningRev(metadata);
      if (local) {
        var docIdRev = docId + "::" + rev;
        // remove all seq entries
        // associated with this docId
        var start = docId + "::";
        var end = docId + "::~";
        var index = seqStore.index('_doc_id_rev');
        var range = IDBKeyRange.bound(start, end, false, false);
        var seqCursor = index.openCursor(range);
        seqCursor.onsuccess = function (e) {
          seqCursor = e.target.result;
          if (!seqCursor) {
            // done
            docStore.delete(cursor.primaryKey);
            cursor.continue();
          } else {
            var data = seqCursor.value;
            if (data._doc_id_rev === docIdRev) {
              localStore.put(data);
            }
            seqStore.delete(seqCursor.primaryKey);
            seqCursor.continue();
          }
        };
      } else {
        cursor.continue();
      }
    } else if (cb) {
      cb();
    }
  };
}

// migration to version 4 (part 2)
function migrateAttsAndSeqs(txn, callback) {
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var attStore = txn.objectStore(ATTACH_STORE);
  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

  // need to actually populate the table. this is the expensive part,
  // so as an optimization, check first that this database even
  // contains attachments
  var req = attStore.count();
  req.onsuccess = function (e) {
    var count = e.target.result;
    if (!count) {
      return callback(); // done
    }

    seqStore.openCursor().onsuccess = function (e) {
      var cursor = e.target.result;
      if (!cursor) {
        return callback(); // done
      }
      var doc = cursor.value;
      var seq = cursor.primaryKey;
      var atts = Object.keys(doc._attachments || {});
      var digestMap = {};
      for (var j = 0; j < atts.length; j++) {
        var att = doc._attachments[atts[j]];
        digestMap[att.digest] = true; // uniq digests, just in case
      }
      var digests = Object.keys(digestMap);
      for (j = 0; j < digests.length; j++) {
        var digest = digests[j];
        attAndSeqStore.put({
          seq: seq,
          digestSeq: digest + '::' + seq
        });
      }
      cursor.continue();
    };
  };
}

// migration to version 5
// Instead of relying on on-the-fly migration of metadata,
// this brings the doc-store to its modern form:
// - metadata.winningrev
// - metadata.seq
// - stringify the metadata when storing it
function migrateMetadata(txn) {

  function decodeMetadataCompat(storedObject) {
    if (!storedObject.data) {
      // old format, when we didn't store it stringified
      storedObject.deleted = storedObject.deletedOrLocal === '1';
      return storedObject;
    }
    return decodeMetadata(storedObject);
  }

  // ensure that every metadata has a winningRev and seq,
  // which was previously created on-the-fly but better to migrate
  var bySeqStore = txn.objectStore(BY_SEQ_STORE);
  var docStore = txn.objectStore(DOC_STORE);
  var cursor = docStore.openCursor();
  cursor.onsuccess = function (e) {
    var cursor = e.target.result;
    if (!cursor) {
      return; // done
    }
    var metadata = decodeMetadataCompat(cursor.value);

    metadata.winningRev = metadata.winningRev ||
      calculateWinningRev(metadata);

    function fetchMetadataSeq() {
      // metadata.seq was added post-3.2.0, so if it's missing,
      // we need to fetch it manually
      var start = metadata.id + '::';
      var end = metadata.id + '::\uffff';
      var req = bySeqStore.index('_doc_id_rev').openCursor(
        IDBKeyRange.bound(start, end));

      var metadataSeq = 0;
      req.onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          metadata.seq = metadataSeq;
          return onGetMetadataSeq();
        }
        var seq = cursor.primaryKey;
        if (seq > metadataSeq) {
          metadataSeq = seq;
        }
        cursor.continue();
      };
    }

    function onGetMetadataSeq() {
      var metadataToStore = encodeMetadata(metadata,
        metadata.winningRev, metadata.deleted);

      var req = docStore.put(metadataToStore);
      req.onsuccess = function () {
        cursor.continue();
      };
    }

    if (metadata.seq) {
      return onGetMetadataSeq();
    }

    fetchMetadataSeq();
  };

}

export {
  addDeletedOrLocalIndex,
  migrateAttsAndSeqs,
  migrateLocalStore,
  migrateMetadata
};